<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>DPDK Metrics Dashboard</title>
<style>
body {
  font-family: monospace;
  margin: 0;
  overflow: hidden;
  background: #f5f5f5;
  /* æ‹–æ‹½æ—¶é˜²æ­¢é€‰ä¸­æ–‡å­—ï¼Œå·²åœ¨console-headerä¸­è®¾ç½® */
  /* user-select: none; */
}
.toolbar {
  padding: 8px;
  background: #222;
  color: #eee;
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
}
.toolbar button {
  padding: 6px 12px;
  background: #444;
  color: #fff;
  border: none;
  border-radius: 3px;
  cursor: pointer;
}
.toolbar button:hover {
  background: #555;
}
.toolbar button:disabled {
  background: #333;
  cursor: not-allowed;
  opacity: 0.6;
}
.toolbar input {
  padding: 6px 10px;
  background: #333;
  color: #fff;
  border: 1px solid #555;
  border-radius: 3px;
  font-family: monospace;
  font-size: 12px;
  min-width: 250px;
}
.toolbar input:disabled {
  background: #2a2a2a;
  cursor: not-allowed;
}
.toolbar input:focus {
  outline: none;
  border-color: #2196F3;
}
.toolbar label {
  font-size: 12px;
  color: #aaa;
}
.url-group {
  display: flex;
  align-items: center;
  gap: 6px;
}
.toolbar .status {
  margin-left: auto;
  display: flex;
  align-items: center;
  gap: 8px;
}
.status-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #f44;
}
.status-dot.connected {
  background: #4f4;
}
.container {
  overflow: auto;
  height: calc(100vh - 50px);
  padding-bottom: 160px;   /* ğŸ‘ˆ åº•éƒ¨ç•™ç™½ */
  /*
  background: white;
  background: black;
  */
  background: #1c1c1c;
}
table {
  border-collapse: collapse;
  width: 100%;
  /*
  table-layout: auto;
  */
  table-layout: fixed;
  position: relative;
}
th, td {
	/*
  border: 1px solid #ccc;
  */
  border: 1px solid #333;
  padding: 8px;
  white-space: nowrap;
  text-align: right;
  min-width: 100px;
}

:root {
  --metric-col-width: 220px;
  --console-alpha: 0.8;
  --glass-blur: 10px;
}

.col-resizer {
  position: absolute;
  right: 0;
  top: 0;
  width: 6px;
  height: 100%;
  cursor: col-resize;
  background: transparent;
}

th.metric {
  background: #1a1a1a;
  color: #ddd;
  text-align: left;
  position: sticky;
  top: 0;
  left: 0;
  z-index: 40;
  font-weight: bold;
  width: var(--metric-col-width);
  min-width: 120px;
  max-width: 480px;
  isolation: isolate;
}

/* ğŸ‘‡ æ–°å¢è¿™ä¸ªè§„åˆ™ */
tbody th.metric {
  position: sticky;
  top: 10px;  /* è®¾ç½®ä¸ºè¡¨å¤´è¡Œçš„é«˜åº¦ï¼Œè®©å®ƒåœåœ¨è¡¨å¤´ä¸‹æ–¹ */
  left: 0;
  z-index: 11;  /* é«˜äºæ™®é€štd(10)ï¼Œä½†ä½äºtheadçš„th.metric(40) */
  background: #1a1a1a;
}

td.metric {
	/*
  background: #4CAF50;
  color: white;
  */
  background: #1a1a1a;
  color: #ddd;
  text-align: left;
  position: sticky;
  left: 0;
  z-index: 10;
  font-weight: bold;
  width: var(--metric-col-width);
  min-width: 120px;
  max-width: 480px;
}
th.metric:hover .col-resizer {
  background: rgba(255,255,255,0.05);
}
th.port {
	/*
  background: #2196F3;
  background: #333;
  color: white;
  */
  background: #2a2a2a;
  color: #ccc;
  position: sticky;
  top: 0;
  z-index: 20;
}
th.total {
	/*
  background: #FF9800;
  background: #3a3a3a;
  color: white;
  */
  background: #2f2f2f;
  color: #ccc;
  position: sticky;
  top: 0;
  z-index: 20;
}
.group-header {
	/*
  background: #e0e0e0;
  */
  background: #2e2e2e;
  color: #bbb;
  font-weight: bold;
  text-align: left;
}
.group-header td {
  background: #2e2e2e;
}
.xstats {
  background: #fff8e1;
}
.xstats-group {
	/*
  background: #fff8e1;
  */
  background: #2a2a2a;
}
.xstats-group th.metric {
	/*
  background: #FFA726;
  color: white;
  */
  background: #383838;
  color: #ddd;
}
.xstats-group td {
	/*
  background: #ffecb3;
  */
  background: #1f1f1f;
}
.error-value {
  color: #f44336;
  font-weight: bold;
}
.value-main {
  font-size: 14px;
  font-weight: bold;
  min-height: 18px;
}
.value-delta {
  font-size: 11px;
  color: #666;
  min-height: 14px;
}
.value-rate {
  font-size: 11px;
  color: #2196F3;
  min-height: 14px;
}
.no-data {
  padding: 40px;
  text-align: center;
  color: #999;
}

table td {
  /*
  background: #fafafa;
  color: #111;
  */
  background: #1e1e1e;
  /*
  background: #1b1b1b;
  */
  color: #ddd;
}

/* æ™®é€šæ•°æ®è¡Œ hover */
/*
table tr:hover td {
  background: #242424;
}
*/
/* æ›´ç²¾è‡´ä¸€ç‚¹ï¼ˆåªåœ¨ tbodyï¼‰ */
table tr:not(.group-header):hover td {
  background: #242424;
}

/* Group header ä¸å‚ä¸ hover */
.group-header:hover td,
.group-header:hover th {
  background: #2e2e2e;
}


/* ä¿è¯ sticky è¡¨å¤´åœ¨æš—èƒŒæ™¯ä¸Šä¸â€œæ¼å…‰â€
 é¿å…æ»šåŠ¨æ—¶å‡ºç°å¥‡æ€ªçš„äº®çº¿ã€‚*/
th {
  background-clip: padding-box;
  /* æ¨ªå‘æ»šåŠ¨æ—¶ header è¾¹ç¼˜æœ‰ä¸€æ¡äº®çº¿ï¼ˆä¼¼ä¹ä¸èµ·ä½œç”¨ï¼‰ */
  box-shadow: inset 0 -1px 0 #333;
}




#console {
  position: fixed;
  right: 20px;
  bottom: 20px;
  width: 750px;
  height: 500px;
  /*
  background: #1e1e1e;
  */
  background: rgba(30,30,30,var(--console-alpha));
  /* macOS é‚£ç§æ¯›ç»ç’ƒæ„Ÿã€‚åŠ¨æ€å®ç°ï¼Œè¿™é‡Œä¸è®¾ç½® */
  /*
  backdrop-filter: blur(1px);
  -webkit-backdrop-filter: blur(8px);
  */
  color: #ddd;
  border: 1px solid #444;
  border-radius: 6px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4);
  display: flex;
  flex-direction: column;
  z-index: 9999;
  font-size: 11px;              /* ğŸ‘ˆ æ•´ä½“å­—ä½“å˜å° */
  line-height: 1.3;
  /* å…è®¸ resize */
  resize: both;
  overflow: hidden;   /* é˜²æ­¢ resize æ—¶å¤–æº¢ */
  min-width: 300px;
  min-height: 180px;
  max-width: 90vw;
  max-height: 90vh;
}

/* ===== Console Glass Mode ===== */
#console.glass {
  /* æ¯›ç»ç’ƒæ—¶é€‚å½“æé«˜é€æ˜åº¦ï¼Œå¦åˆ™å‘ç° */
  background: rgba(30,30,30,0.65); /* å›ºå®šå€¼ï¼Œåˆ«å†å  alpha */
  backdrop-filter: blur(var(--glass-blur));
  -webkit-backdrop-filter: blur(var(--glass-blur));
}

/* Glass æ¨¡å¼ä¸‹è‡ªåŠ¨æé«˜å¯¹æ¯”åº¦ */
#console.glass .log-line {
  text-shadow: 0 0 2px rgba(0,0,0,0.5);
}

#console.hidden { display: none; }

#console-header {
  background: transparent;
  padding: 4px 8px;
  font-weight: bold;
  cursor: move;
  display: flex;
  justify-content: space-between;
  user-select: none;
}

#console-header button {
  padding: 0 6px;
  font-size: 12px;
  line-height: 16px;
  height: 16px;
  background: transparent;
  border: none;
  color: #888;
  cursor: pointer;
}

#console-header button:hover {
  color: #fff;
}

.console-header-tools {
  display: flex;
  align-items: center;
  gap: 6px;      /* ğŸ‘ˆ åŸæ¥å¯èƒ½åå¤§ */
}
/*
æ¨èçš„æœ€ç»ˆå°ºå¯¸å‚è€ƒ
å…ƒç´ 	å­—å·
Console å†…å®¹	11px
å·¥å…·æŒ‰é’®	10px
Slider thumb	10px
å…³é—­ X	12px
*/




#console-tabs {
  display: flex;
  background: transparent;
}
#console-tabs button {
  flex: 1;
  padding: 4px;
  background: none;
  border: none;
  color: #aaa;
  cursor: pointer;
  font-size: 11px;
}
#console-tabs button.active {
  color: #fff;
  /*
  background: #333;
  */
  /*
  background: transparent;
  box-shadow: inset 0 -1px 0 #888;   /* ä¸‹è¾¹æ¡†æŒ‡ç¤ºå½“å‰ tab */
  /*
  color: #fff;
  background: rgba(255,255,255,0.08); /* åŠé€æ˜é«˜äº® */
}

#console-body {
  flex: 1;
  overflow: visible;
  display: flex;
  flex-direction: column;
  min-height: 0;   /* ğŸ”´ éå¸¸é‡è¦ */
}

.tab {
  flex: 1;
  display: none;
  flex-direction: column;
  min-height: 0;   /* ğŸ”´ å¿…é¡» */
}
.tab.active { display: flex; }

.log-area, .cmd-output {
  flex: 1;
  padding: 6px;
  overflow-y: auto;        /* æ»šåŠ¨æ¡ */
  overflow-x: hidden;
  white-space: pre-wrap;
  font-family: monospace;
  font-size: 11px;
  line-height: 1.3;
  min-height: 0;           /* ğŸ”´ å…³é”®ï¼šflex åœºæ™¯ä¸‹å…è®¸æ»šåŠ¨ */
  background: transparent;
}

.log-line {
  margin-bottom: 2px;
}

/* Log actions */
.console-actions {
  display: flex;
  gap: 6px;
  padding: 4px 6px;
  border-bottom: 1px solid #333;
  align-items: center;
  background: transparent;
}
.console-actions label {
  color: #aaa;
  font-size: 11px;
  background: transparent;
}
.console-actions input {
  width: 60px;
  background: #111;
  color: #fff;
  border: 1px solid #333;
  font-size: 11px;
}
.console-actions button {
  padding: 2px 6px;          /* ğŸ‘ˆ æ˜æ˜¾å˜å° */
  font-size: 10px;
  line-height: 1.2;
  border-radius: 3px;
  background: #333;
  color: #ccc;
  border: 1px solid #444;
}

.console-actions button:hover {
  background: #3a3a3a;
  color: #fff;
}

/* â€œconsole ä¸“ç”¨ sliderâ€ */
#console input[type="range"] {
  height: 22px;              /* ğŸ‘ˆ å‘½ä¸­åŒºåŸŸæ›´é«˜ */
  padding: 0;
  margin: 0 6px;
  background: transparent;
  cursor: pointer;
  position: relative;
}

#console input[type="range"]::before {
  content: "";
  position: absolute;
  left: 0;
  right: 0;
  top: 50%;
  height: 16px;              /* ğŸ‘ˆ æ›´å¤§çš„å‘½ä¸­åŒº */
  transform: translateY(-50%);
}

/* macOS é£æ ¼ */
#console input[type="range"]::-webkit-slider-runnable-track {
  height: 2px;
  background: #555;
  border-radius: 2px;
}

#console input[type="range"]::-moz-range-track {
  height: 2px;
  background: #555;
  border-radius: 2px;
}

#console input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 8px;                /* ğŸ‘ˆ æ¯”ä¹‹å‰å° */
  height: 8px;
  border-radius: 50%;
  background: #ccc;
  margin-top: -3px;          /* ğŸ‘ˆ å‚ç›´å±…ä¸­ */
  cursor: pointer;
}

#console input[type="range"]::-moz-range-thumb {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #ccc;
  border: none;
  cursor: pointer;
}


/* Hover æ—¶å¢åŠ å¯æ„ŸçŸ¥æ€§ï¼ˆä½†ä¸å˜å¤§ï¼‰ */
#console input[type="range"]:hover::-webkit-slider-thumb {
  background: #fff;
}

#console input[type="range"]:hover::-webkit-slider-runnable-track {
  background: #666;
}



/* Cmd input */
.cmd-input {
  border-top: 1px solid #333;
  padding: 4px;
}
.cmd-input textarea {
  width: 100%;
  height: 48px;
  resize: none;
  background: #111;
  color: #fff;
  border: 1px solid #333;
  font-family: monospace;
  font-size: 11px;
}
.cmd-hint {
  font-size: 10px;
  color: #777;
  margin-top: 2px;
}

/* Toggle button */
#console-toggle {
  position: fixed;
  right: 20px;
  bottom: 20px;
  padding: 6px 10px;
  background: #444;
  color: #fff;
  border: none;
  border-radius: 4px;
  z-index: 9998;
}



</style>




<div id="console" class="hidden">
  <div id="console-header">
	  <span>Console</span>

  <div class="console-header-tools">
    <!-- Glass toggle -->
    <label style="font-size:10px; opacity:0.8;">
    <input type="checkbox" id="glassToggle">
    Glass
    </label>

  <!-- Opacity slider -->
    <input id="opacitySlider"
		   type="range"
           min="50" max="100" value="80"
           title="Opacity"
           oninput="setConsoleOpacity(this.value)">

	  <!-- Blur slider -->
	  <input id="blurSlider"
         type="range"
         min="0" max="30" value="10"
         title="Blur"
         style="display:none">

    <button onclick="toggleConsole()">âœ•</button>
  </div>
  </div>

  <div id="console-tabs">
    <button class="active" onclick="switchTab('log', event)">Log</button>
    <button onclick="switchTab('cmd', event)">Cmd</button>
  </div>

  <div id="console-body">

    <!-- Log Tab -->
    <div id="tab-log" class="tab active">
      <div class="console-actions">
		    <button onclick="clearLog()">Clear</button>

			  <label>Max:</label>
			  <input id="maxLogLinesInput" type="number" value="100" min="50" />

			  <label>
				<input type="checkbox" id="newestFirstToggle" checked />
				Newest first
			  </label>

			  <label>
				<input type="checkbox" id="freezeToggle" />
				Freeze
			  </label>
      </div>
      <div id="logArea" class="log-area"></div>
    </div>

    <!-- Cmd Tab -->
    <div id="tab-cmd" class="tab">
      <div id="cmdOutput" class="cmd-output"></div>
      <div class="cmd-input">
        <textarea id="cmdInput" placeholder="Enter command..."></textarea>
        <div class="cmd-hint">Ctrl + Enter to send</div>
      </div>
    </div>

  </div>
</div>

<button id="console-toggle" onclick="toggleConsole()">Console</button>






</head>
<body>
<div class="toolbar">
  <div class="url-group">
    <label for="wsUrlInput">Server:</label>
    <input type="text" id="wsUrlInput" placeholder="ws://localhost:8080/wsURL" />
  </div>
  <button onclick="toggleConnection()" id="connectBtn">Connect</button>
  <button onclick="toggleMode()">Mode: <span id="mode">Formatted</span></button>
  <button onclick="toggleRate()">Rate: <span id="rateMode">ON</span></button>
  <button onclick="toggleTotal()">Total: <span id="totalMode">SHOW</span></button>
  <div class="status">
    <span class="status-dot" id="statusDot"></span>
    <span id="statusText">Disconnected</span>
  </div>
</div>
<div class="container">
  <div id="noData" class="no-data">Click Connect to start receiving data...</div>
  <table id="metrics" style="display: none;"></table>
</div>
<script>
let ws = null;
let prev = {};
let prevTs = 0;
let displayMode = "FORMATTED"; // FORMATTED or RAW
let rateEnabled = true;
let xstatsVisible = true;
let totalVisible = true;
let isConnected = false;

const STATS_ORDER = ['ipackets', 'opackets', 'ibytes', 'obytes', 'imissed', 'ierrors', 'oerrors', 'rx_nombuf'];
const ERROR_KEYS = ['imissed', 'ierrors', 'oerrors', 'rx_nombuf'];

// Initialize WebSocket URL from localStorage or default
const DEFAULT_WS_URL = '/wsURL';
let wsUrl = localStorage.getItem('dpdk_ws_url') || DEFAULT_WS_URL;

// Initialize UI


window.addEventListener("load", () => {
  // WS URL
  const urlInput = document.getElementById('wsUrlInput');
  urlInput.value = wsUrl;

  // Opacity
  const savedOpacity = localStorage.getItem("console_opacity") || DEFAULT_OPACITY;
  opacitySlider.value = savedOpacity;
  setConsoleOpacity(savedOpacity);

  // Blur
  const savedBlur = localStorage.getItem("console_blur") || 10;
  blurSlider.value = savedBlur;
  setGlassBlur(savedBlur);

  // Glass mode
  const glassSaved = localStorage.getItem("console_glass") === "1";
  glassToggle.checked = glassSaved;
  setGlassMode(glassSaved);

  /* macOS ä¸“ç”¨é»˜è®¤å¼€å¯ */
  /*
  const isMac = navigator.platform.includes("Mac");
  if (isMac && localStorage.getItem("console_glass") === null) {
    setGlassMode(true);
  }
  */

  // Allow Enter key to connect
  urlInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !isConnected) {
      toggleConnection();
    }
  });

  const saved = localStorage.getItem("console_opacity") || DEFAULT_OPACITY;
  const slider = document.getElementById("opacitySlider");
  slider.value = saved;
  setConsoleOpacity(saved);
});



function normalizeWsUrl(url) {
  // Trim whitespace
  url = url.trim();

  // If URL starts with /, treat as relative path
  if (url.startsWith('/')) {
    return url;
  }

  // Auto-add protocol if missing
  if (!url.startsWith('ws://') && !url.startsWith('wss://')) {
    // Use wss:// if page is https://, otherwise ws://
    const protocol = (location.protocol === 'https:') ? 'wss://' : 'ws://';
    url = protocol + url;
  }

  return url;
}

function toggleConnection() {
  if (isConnected) {
    disconnect();
  } else {
    connect();
  }
}

function connect() {
  const urlInput = document.getElementById('wsUrlInput');

  // Get and normalize URL
  wsUrl = normalizeWsUrl(urlInput.value);

  // Save to localStorage
  localStorage.setItem('dpdk_ws_url', wsUrl);

  // Update input to show normalized URL
  urlInput.value = wsUrl;

  try {
    ws = new WebSocket(wsUrl, "Company.ProtoName.json");

    ws.onopen = () => {
      isConnected = true;
      document.getElementById('statusDot').classList.add('connected');
      document.getElementById('statusText').innerText = 'Connected';
      document.getElementById('connectBtn').innerText = 'Disconnect';
      urlInput.disabled = true;
    };

    ws.onmessage = e => {
      try {
        const data = JSON.parse(e.data);
        if (data.ports) {
          render(data);
        }
		if (data.cmdReply) cmdOutput.innerHTML += "% " + data.cmdReply + "\n\n"; // ğŸ‘ˆ æ–°å¢
		if (data.log) appendLog(data.log);   // ğŸ‘ˆ æ–°å¢

      } catch (err) {
        console.error('Parse error:', err);
      }
    };

    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
      document.getElementById('statusText').innerText = 'Connection Error';
    };

    ws.onclose = () => {
      isConnected = false;
      document.getElementById('statusDot').classList.remove('connected');
      document.getElementById('statusText').innerText = 'Disconnected';
      document.getElementById('connectBtn').innerText = 'Connect';
      urlInput.disabled = false;
    };
  } catch (err) {
    console.error('Connection error:', err);
    document.getElementById('statusText').innerText = 'Connection Failed';
    urlInput.disabled = false;
  }
}

function disconnect() {
  if (ws) {
    ws.close();
    ws = null;
  }
}

function toggleMode() {
  displayMode = displayMode === "FORMATTED" ? "RAW" : "FORMATTED";
  document.getElementById("mode").innerText = displayMode === "FORMATTED" ? "Formatted" : "Raw";
}

function toggleRate() {
  rateEnabled = !rateEnabled;
  document.getElementById("rateMode").innerText = rateEnabled ? "ON" : "OFF";
}

function toggleTotal() {
  totalVisible = !totalVisible;
  document.getElementById("totalMode").innerText = totalVisible ? "SHOW" : "HIDE";
  document.querySelectorAll(".total-col").forEach(e => {
    e.style.display = totalVisible ? "" : "none";
  });
}

function formatNumber(v) {
  if (displayMode === "RAW") return v.toLocaleString();
  if (v >= 1e12) return (v / 1e12).toFixed(2) + ' T';
  if (v >= 1e9) return (v / 1e9).toFixed(2) + ' G';
  if (v >= 1e6) return (v / 1e6).toFixed(2) + ' M';
  if (v >= 1e3) return (v / 1e3).toFixed(2) + ' K';
  return v.toLocaleString();
}

function formatRate(rate, isBytes) {
  if (!rate || rate === 0) return '0';
  if (isBytes) {
    const bits = rate * 8;
    if (bits >= 1e9) return (bits / 1e9).toFixed(2) + ' Gbps';
    if (bits >= 1e6) return (bits / 1e6).toFixed(2) + ' Mbps';
    if (bits >= 1e3) return (bits / 1e3).toFixed(2) + ' Kbps';
    return bits.toFixed(0) + ' bps';
  } else {
    if (rate >= 1e6) return (rate / 1e6).toFixed(2) + ' Mpps';
    if (rate >= 1e3) return (rate / 1e3).toFixed(2) + ' Kpps';
    return rate.toFixed(0) + ' pps';
  }
}

function render(data) {
  document.getElementById('noData').style.display = 'none';
  const table = document.getElementById('metrics');
  table.style.display = 'table';
  table.innerHTML = "";
  const thead = document.createElement("thead");
  const tbody = document.createElement("tbody");
  table.appendChild(thead);
  table.appendChild(tbody);

  const ports = Object.keys(data.ports).sort();
  const currentTs = data.meta?.timestamp_ns || Date.now() * 1e6;
  const timeDelta = prevTs ? (currentTs - prevTs) / 1e9 : 1;

  // Header row
  let headerRow = document.createElement("tr");
	headerRow.innerHTML = `<th class="metric">Metric<div class="col-resizer"></div></th>`;
  if (totalVisible) {
    headerRow.innerHTML += `<th class="port total total-col">Total</th>`;
  }
  ports.forEach(p => {
    headerRow.innerHTML += `<th class="port">Port ${p}</th>`;
  });
  thead.appendChild(headerRow);

  // Render STATS group
  renderGroup(tbody, "STATS", STATS_ORDER, data, ports, timeDelta, false, null);

  // Render XSTATS - handle flat structure
  if (data.ports[ports[0]].xstats) {
    const allXstatsKeys = Object.keys(data.ports[ports[0]].xstats);

    if (allXstatsKeys.length > 0) {
      // Group xstats by prefix (rx_, tx_, etc.)
      const groups = {
        'RX': [],
        'TX': [],
        'Queue': [],
        'PHY': [],
        'Other': []
      };

      allXstatsKeys.forEach(key => {
        if (key.startsWith('rx_q') || key.startsWith('tx_q')) {
          groups['Queue'].push(key);
        } else if (key.startsWith('rx_phy') || key.startsWith('tx_phy')) {
          groups['PHY'].push(key);
        } else if (key.startsWith('rx_')) {
          groups['RX'].push(key);
        } else if (key.startsWith('tx_')) {
          groups['TX'].push(key);
        } else {
          groups['Other'].push(key);
        }
      });

      // Render each group
      Object.keys(groups).forEach(groupName => {
        if (groups[groupName].length > 0) {
          renderGroup(tbody, `XSTATS - ${groupName}`, groups[groupName], data, ports, timeDelta, true, 'flat');
        }
      });
    }
  }

  // Save previous data
  prevTs = currentTs;
  prev = {};
  ports.forEach(p => {
    prev[p] = {
      stats: { ...data.ports[p].stats },
      xstats: { ...data.ports[p].xstats } // Flat structure
    };
  });
}

function renderGroup(tbody, title, keys, data, ports, timeDelta, isXstats, category = null) {
  // Group header
  let groupRow = document.createElement("tr");
  groupRow.className = isXstats ? "xstats-group" : "";
  groupRow.innerHTML = `<th class="metric group-header">${title}</th>`;
  if (totalVisible) {
    groupRow.innerHTML += `<td class="group-header total-col"></td>`;
  }
  ports.forEach(() => {
    groupRow.innerHTML += `<td class="group-header"></td>`;
  });
  tbody.appendChild(groupRow);

  // Data rows
  keys.forEach(key => {
    let row = document.createElement("tr");
    row.className = isXstats ? "xstats" : "";

    // Metric name
    row.innerHTML = `<th class="metric">${key}</th>`;

    // Calculate total
    let total = 0;
    let prevTotal = 0;
    ports.forEach(p => {
      const portData = data.ports[p];
      let current = 0;
      let previous = 0;

      if (!isXstats) {
        current = portData.stats[key] || 0;
        previous = prev[p]?.stats[key] || current;
      } else {
        // Handle flat xstats structure
        current = portData.xstats?.[key] || 0;
        previous = prev[p]?.xstats?.[key] || current;
      }

      total += current;
      prevTotal += previous;
    });

    // Total column
    if (totalVisible) {
      const delta = total - prevTotal;
      const rate = timeDelta > 0 ? delta / timeDelta : 0;
      const isBytes = key.includes('bytes') || key.includes('byte');
      const isPackets = key.includes('packets') || key.includes('packet');
      const isError = ERROR_KEYS.includes(key) || key.includes('error') || key.includes('missed');
      const canCalculateRate = isBytes || isPackets;

      let cellHtml = `<td class="total-col ${isError && total > 0 ? 'error-value' : ''}">`;
      cellHtml += `<div class="value-main">${formatNumber(total)}</div>`;

      // Always reserve space for delta
      if (delta !== 0) {
        cellHtml += `<div class="value-delta">Î” ${delta >= 0 ? '+' : ''}${formatNumber(delta)}</div>`;
      } else {
        cellHtml += `<div class="value-delta">&nbsp;</div>`;
      }

      // Always reserve space for rate if applicable
      if (canCalculateRate) {
        if (rateEnabled && rate !== 0) {
          cellHtml += `<div class="value-rate">${formatRate(rate, isBytes)}</div>`;
        } else {
          cellHtml += `<div class="value-rate">&nbsp;</div>`;
        }
      }

      cellHtml += `</td>`;
      row.innerHTML += cellHtml;
    }

    // Port columns
    ports.forEach(p => {
      const portData = data.ports[p];
      let current = 0;
      let previous = 0;

      if (!isXstats) {
        current = portData.stats[key] || 0;
        previous = prev[p]?.stats[key] || current;
      } else {
        // Handle flat xstats structure
        current = portData.xstats?.[key] || 0;
        previous = prev[p]?.xstats?.[key] || current;
      }

      const delta = current - previous;
      const rate = timeDelta > 0 ? delta / timeDelta : 0;
      const isBytes = key.includes('bytes') || key.includes('byte');
      const isPackets = key.includes('packets') || key.includes('packet');
      const isError = ERROR_KEYS.includes(key) || key.includes('error') || key.includes('missed');
      const canCalculateRate = isBytes || isPackets;

      let cellHtml = `<td class="${isError && current > 0 ? 'error-value' : ''}">`;
      cellHtml += `<div class="value-main">${formatNumber(current)}</div>`;

      // Always reserve space for delta
      if (delta !== 0) {
        cellHtml += `<div class="value-delta">Î” ${delta >= 0 ? '+' : ''}${formatNumber(delta)}</div>`;
      } else {
        cellHtml += `<div class="value-delta">&nbsp;</div>`;
      }

      // Always reserve space for rate if applicable
      if (canCalculateRate) {
        if (rateEnabled && rate !== 0) {
          cellHtml += `<div class="value-rate">${formatRate(rate, isBytes)}</div>`;
        } else {
          cellHtml += `<div class="value-rate">&nbsp;</div>`;
        }
      }

      cellHtml += `</td>`;
      row.innerHTML += cellHtml;
    });

    tbody.appendChild(row);
  });
}


const consoleEl = document.getElementById("console");
const logArea = document.getElementById("logArea");
const cmdOutput = document.getElementById("cmdOutput");
const maxLogInput = document.getElementById("maxLogLinesInput");
const newestFirstToggle = document.getElementById("newestFirstToggle");
const freezeToggle = document.getElementById("freezeToggle");

const cmdInput = document.getElementById("cmdInput");

let MAX_LOG_LINES = parseInt(maxLogInput.value, 10);
// let MAX_LOG_LINES = 100;
let newestFirst = true;
let freezeLog = false;

maxLogInput.onchange = () => {
  MAX_LOG_LINES = parseInt(maxLogInput.value, 10) || 100;
};

newestFirstToggle.onchange = () => {
  newestFirst = newestFirstToggle.checked;
};

freezeToggle.onchange = () => {
  freezeLog = freezeToggle.checked;
};

/* ---------- Console ---------- */
function toggleConsole() {
  consoleEl.classList.toggle("hidden");
}

function switchTab(name, ev) {
  document.querySelectorAll("#console-tabs button").forEach(b => b.classList.remove("active"));
  document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
  document.getElementById("tab-" + name).classList.add("active");
  ev.target.classList.add("active");
}

/* ---------- Log ---------- */
function appendLog(log) {
  if (freezeLog) return;   // â¸ å†»ç»“æ—¥å¿—

  const div = document.createElement("div");
  div.className = "log-line";

  const ts = new Date().toISOString();

  const text =
    typeof log === "string" ? log :
    log.text ? log.text :
    JSON.stringify(log);

  div.textContent = `[${ts}] ${text}`;

  if (newestFirst) {
    // æœ€æ–°åœ¨å‰
    logArea.insertBefore(div, logArea.firstChild);
  } else {
    // æœ€æ–°åœ¨å
    logArea.appendChild(div);
  }

  // è£å‰ªå¤šä½™æ—¥å¿—
  while (logArea.children.length > MAX_LOG_LINES) {
    if (newestFirst) {
      logArea.removeChild(logArea.lastChild);
    } else {
      logArea.removeChild(logArea.firstChild);
    }
  }

  // è‡ªåŠ¨æ»šåŠ¨ç­–ç•¥
  if (newestFirst) {
    logArea.scrollTop = 0;
  } else {
    logArea.scrollTop = logArea.scrollHeight;
  }
}


function clearLog() {
  logArea.innerHTML = "";
}

/* ---------- Cmd ---------- */
cmdInput.addEventListener("keydown", e => {
  if (e.key === "Enter" && e.ctrlKey) {
    e.preventDefault();
    sendCmd();
  }
});

function sendCmd() {
  if (!ws || ws.readyState !== WebSocket.OPEN) return;
  const text = cmdInput.value.trim();
  if (!text) return;

  ws.send(JSON.stringify({ cmd: text }));
  cmdOutput.textContent += `> ${text}\n`;
  cmdOutput.scrollTop = cmdOutput.scrollHeight;
  cmdInput.value = "";
}

/* ---------- Drag ---------- */
(() => {
  const header = document.getElementById("console-header");
  let drag = false, ox = 0, oy = 0;

  header.onmousedown = e => {
    drag = true;
    ox = e.clientX - consoleEl.offsetLeft;
    oy = e.clientY - consoleEl.offsetTop;
  };
  document.onmousemove = e => {
    if (!drag) return;
    consoleEl.style.left = e.clientX - ox + "px";
    consoleEl.style.top  = e.clientY - oy + "px";
    consoleEl.style.right = "auto";
    consoleEl.style.bottom = "auto";
  };
  document.onmouseup = () => drag = false;
})();


const DEFAULT_OPACITY = 80;

/*
function setConsoleOpacity(v) {
  localStorage.setItem("console_opacity", v);
  const a = v / 100;
  consoleEl.style.background = `rgba(30,30,30,${a})`;
}
*/
function setConsoleOpacity(v) {
  const a = v / 100;
  document.documentElement.style
    .setProperty("--console-alpha", a);
  localStorage.setItem("console_opacity", v);
}


function setGlassBlur(v) {
  document.documentElement.style
    .setProperty("--glass-blur", v + "px");
  localStorage.setItem("console_blur", v);
}


function setGlassMode(enabled) {
  if (enabled) {
    consoleEl.classList.add("glass");

    blurSlider.style.display = "";
    opacitySlider.style.display = "none";
  } else {
    consoleEl.classList.remove("glass");

    blurSlider.style.display = "none";
    opacitySlider.style.display = "";
  }

  localStorage.setItem("console_glass", enabled ? "1" : "0");
}


/* æ‹–æ‹½è¡¨å¤´ */
(function () {
  let resizing = false;
  let startX = 0;
  let startWidth = 0;

  document.addEventListener("mousedown", e => {
    if (!e.target.classList.contains("col-resizer")) return;

    resizing = true;
    startX = e.clientX;
    const th = e.target.parentElement;
    startWidth = th.offsetWidth;

    document.body.style.cursor = "col-resize";
    e.preventDefault();
  });

  document.addEventListener("mousemove", e => {
    if (!resizing) return;

    const dx = e.clientX - startX;
    const newWidth = Math.min(
      480,
      Math.max(120, startWidth + dx)
    );

    document.documentElement.style
      .setProperty("--metric-col-width", newWidth + "px");
  });

  document.addEventListener("mouseup", () => {
    if (!resizing) return;
    resizing = false;
    document.body.style.cursor = "";
  });
})();


const glassToggle = document.getElementById("glassToggle");
const opacitySlider = document.getElementById("opacitySlider");
const blurSlider    = document.getElementById("blurSlider");

glassToggle.addEventListener("change", () => {
  setGlassMode(glassToggle.checked);
});

opacitySlider.addEventListener("input", e => {
  setConsoleOpacity(e.target.value);
});

blurSlider.addEventListener("input", e => {
  setGlassBlur(e.target.value);
});





</script>
</body>
</html>
